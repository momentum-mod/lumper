namespace Lumper.Lib.Util;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using NLog;

public static class AssetManifest
{
    /// <summary>
    /// An asset from an existing Source, usually Valve assets that we want to flag/get rid of.
    ///
    /// assetmanifest.rsv also stores CRC32 and length. We have no use for these currently, so omitting.
    /// </summary>
    public class Asset
    {
        /// <summary>
        /// The game or asset pack the asset is from.
        /// </summary>
        public required string Origin { get; init; }

        /// <summary>
        /// The path and filename of the asset, relative from its origin.
        /// </summary>
        public required string Path { get; init; }
    }

    private static readonly Lazy<Dictionary<string, List<Asset>>> LazyManifest = new(Load);

    /// <summary>
    /// Dictionary of assets loaded from the asset.manifest file, keyed by SHA1 hash of the asset.
    /// Valve games contain a surprising number of duplicate assets (i.e. matching hashes) so we store a list
    /// of assets rather than single assets.
    /// </summary>
    public static Dictionary<string, List<Asset>> Manifest => LazyManifest.Value;

    /// <summary>
    /// Every game or asset pack that has assets in the manifest.
    /// </summary>
    public static HashSet<string> Origins { get; } = [];

    /// <summary>
    /// Preload the asset manifest. UI wants this, CLI doesn't. Don't call from the UI thread!
    /// </summary>
    public static void Preload() => _ = Manifest;

    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    private static Dictionary<string, List<Asset>> Load()
    {
        try
        {
            var stopwatch = new Stopwatch();
            stopwatch.Start();

            var manifest = new Dictionary<string, List<Asset>>();

            // We could add checks around all the asset manifest-related code to support ignoring it, but it's always used
            // in Momentum's use-case, so not putting the effort in, and throwing if the manifest isn't found.
            string manifestPath = Path.Combine(AppContext.BaseDirectory, "AssetManifest.rsv");
            if (!File.Exists(manifestPath))
                throw new IOException("Could not find AssetManifest.rsv");

            // This file is generated by running https://github.com/stratasource/verifier with `./verifier.exe --new-index`
            // on a directory full of VPKs from every Valve game.
            //
            // (Momentum Team note: we have a directory full of all VPKs and certain directories we want to exclude in
            // the "Valve VPKs" dir on teamstorage.)
            //
            // It's in RSV (https://github.com/stenway/rsv-specification), with the following structure:
            // <origin vpk>\xFF<path>\xFF<content length>\xFF\<sha1 hash>\xFF<crc32>\xFF\xFD
            // (see https://github.com/Stenway/RSV-Challenge/blob/4948917321f9ae2cef0beb73be41dc959d07bd0b/CS/Rsv.cs#L30).
            using Stream stream = File.OpenRead(manifestPath);
            using var reader = new BinaryReader(stream);

            // First buffer (vpk), second buffer (path), third buffer (content length), fourth buffer (hash).
            // Third buffer (content length) isn't used, but we need to read it to advance the stream.
            byte[][] buffers = [new byte[256], new byte[256], new byte[64], new byte[40]];
            // First, second and third buffers are variable length, fourth buffer is always 40 bytes.
            // Simpler code and equal-to-faster perf to treat each buffer-length combo the same, and read into all.
            int[] bufferLengths = [0, 0, 0, 0];

            int currentSection = 0;
            // Last byte will be a \xFD, which would break our inner loop, so loop until we're definitely in the last row.
            long end = reader.BaseStream.Length - 2;
            var decoder = new UTF8Encoding(false, false);
            while (reader.BaseStream.Position <= end)
            {
                int i;
                byte read;
                // Fill current buffer until we hit 0xFF.
                for (i = 0; (read = reader.ReadByte()) != 0xFF; i++)
                    buffers[currentSection][i] = read;

                // Advance section
                bufferLengths[currentSection] = i;
                currentSection++;

                // Parse out an Asset once we reach section 4.
                if (currentSection != 4)
                    continue;

                string vpk = decoder.GetString(buffers[0], 0, bufferLengths[0]);
                string path = decoder.GetString(buffers[1], 0, bufferLengths[1]);
                string hash = decoder.GetString(buffers[3], 0, bufferLengths[3]);

                int vpkFirstSlash = vpk.IndexOf('/');
                string origin;
                // If not in a VPK, `vpk` is just `.`, and the path will start with origin (e.g. l4d1/dlc1/sound/...)
                if (vpkFirstSlash != -1)
                {
                    origin = vpk[..vpkFirstSlash];
                }
                else
                {
                    int pathFirstSlash = path.IndexOf('/');
                    origin = pathFirstSlash == -1 ? "UNKNOWN" : path[..pathFirstSlash];
                }

                var asset = new Asset { Origin = origin, Path = path };

                if (!manifest.TryAdd(hash, [asset]))
                    manifest[hash].Add(asset);

                Origins.Add(origin);

                // Skip past section 5 and to next row, skipping: crc32 (8 bytes), \xFF (1 byte), \xFD (1 byte)
                stream.Seek(10, SeekOrigin.Current);
                currentSection = 0;
            }

            stopwatch.Stop();
            Logger.Debug($"Loaded asset manifest in {stopwatch.ElapsedMilliseconds}ms");

            return manifest;
        }
        catch (Exception ex)
        {
            Logger.Error(ex, "Error reading asset manifest!");
            // Just return an empty manifest if something goes wrong.
            return [];
        }
    }
}
